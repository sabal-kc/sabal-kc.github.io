<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://sabal-kc.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sabal-kc.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-30T15:28:25+00:00</updated><id>https://sabal-kc.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. </subtitle><entry><title type="html">Exploring a solution for a limitation of RSA encryption</title><link href="https://sabal-kc.github.io/blog/2023/encryption/" rel="alternate" type="text/html" title="Exploring a solution for a limitation of RSA encryption"/><published>2023-06-01T00:00:00+00:00</published><updated>2023-06-01T00:00:00+00:00</updated><id>https://sabal-kc.github.io/blog/2023/encryption</id><content type="html" xml:base="https://sabal-kc.github.io/blog/2023/encryption/"><![CDATA[<p>RSA algorithm is an asymmetric cryptography algorithm that consists of two different keys i.e. Public Key and Private Key. It is one of the most widely used encryption methods to securely transmit information. But it does have some limitations. In this article, I will aim to explain a solution to a problem that arose when trying to encrypt a response payload with this algorithm in golang.</p> <p>To encrypt a response payload with a public key, the approach is to use the EncryptOAEP method from the “crypto/rsa” package. It is an Optimal Asymmetric Encryption Padding (OAEP) algorithm that takes in a random hash as the first parameter (sha256 hash is passed here). The second parameter consists of a random parameter to ensure entropy. Following these two parameters are the public key and the payload (bytes) that is to be encrypted. The final parameter is a label parameter (which does not get encrypted), this is passed as nil.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rsa</span><span class="o">.</span><span class="n">EncryptOAEP</span><span class="p">(</span><span class="n">sha256</span><span class="o">.</span><span class="n">New</span><span class="p">(),</span> <span class="n">rand</span><span class="o">.</span><span class="n">Reader</span><span class="p">,</span> <span class="n">publicKey</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div> <p>This is a sound working approach. However, a limitation is that the message must be no longer than the length of the RSA modulus minus twice the hash length, minus a further 2. Although it works perfectly fine for normal length messages, some payloads exceeded this limit and an error gets thrown: RS256 message too long for RSA public key size.</p> <p>The two common solutions to this problem are:</p> <ol> <li> <p>Hybrid Encryption: In hybrid encryption, a combination of symmetric and asymmetric encryption is used. RSA is used to securely exchange a symmetric encryption key, which is then used to encrypt the actual message. This approach is commonly used in protocols like SSL/TLS for secure communication over the internet.</p> </li> <li> <p>Chunking: Instead of encrypting the entire message as one block, the message is divided into smaller chunks or blocks. Each block is individually encrypted. The encryption is pretty straightforward, where we encrypt m bytes at a time as shown below:</p> </li> </ol> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span> <span class="o">:=</span> <span class="n">sha256</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
<span class="n">m</span> <span class="o">:=</span> <span class="n">maxPayloadSize</span><span class="p">(</span><span class="n">publicKey</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// For the last chunk, go upto the length</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// Encrypt m bytes at a time</span>
    <span class="n">encChunk</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">rsa</span><span class="o">.</span><span class="n">EncryptOAEP</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">rand</span><span class="o">.</span><span class="n">Reader</span><span class="p">,</span> <span class="n">publicKey</span><span class="p">,</span> <span class="n">payload</span><span class="p">[</span><span class="o">:</span><span class="n">m</span><span class="p">],</span> <span class="no">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="c">// Write to some output buffer</span>
    <span class="n">encBytes</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">encChunk</span><span class="p">)</span>

    <span class="c">// Move forward</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="n">m</span><span class="o">:</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here, the max payload size is given by:</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">maxPayloadSize</span><span class="p">(</span><span class="n">key</span> <span class="o">*</span><span class="n">rsa</span><span class="o">.</span><span class="n">PublicKey</span><span class="p">,</span> <span class="n">hash</span> <span class="n">hash</span><span class="o">.</span><span class="n">Hash</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span> <span class="o">-</span> <span class="m">2</span><span class="o">*</span><span class="n">hash</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span> <span class="o">-</span> <span class="m">2</span>
<span class="p">}</span>
</code></pre></div></div> <p>However, for decryption, the chunks must be traversed at a gap of the public key’s length to get the correct result, not the max payload size, since the encrypted result would be of a different size in comparison to the original payload.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span> <span class="o">:=</span> <span class="n">sha256</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
<span class="n">m</span> <span class="o">:=</span> <span class="n">privateKey</span><span class="o">.</span><span class="n">PublicKey</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span>

<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">encBytes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
    <span class="c">// For the last chunk, go upto the length</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">encBytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">encBytes</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// Encrypt m bytes at a time</span>
    <span class="n">decChunk</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">rsa</span><span class="o">.</span><span class="n">DecryptOAEP</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="n">privateKey</span><span class="p">,</span> <span class="n">encBytes</span><span class="p">[</span><span class="o">:</span><span class="n">m</span><span class="p">],</span> <span class="no">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>

    <span class="c">// Write to some output buffer</span>
    <span class="n">decBytes</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">decChunk</span><span class="p">)</span>

    <span class="c">// Move forward</span>
    <span class="n">encBytes</span> <span class="o">=</span> <span class="n">encBytes</span><span class="p">[</span><span class="n">m</span><span class="o">:</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="programming"/><category term="golang"/><category term="encryption"/><summary type="html"><![CDATA[RSA algorithm is an asymmetric cryptography algorithm that consists of two different keys i.e. Public Key and Private Key. It is one of the most widely used encryption methods to securely transmit information. But it does have some limitations. In this article, I will aim to explain a solution to a problem that arose when trying to encrypt a response payload with this algorithm in golang.]]></summary></entry></feed>